## 进程和程序 —— 习题

##### 8.1  从`fork`返回的值能够区分父进程还是子进程吗？还有其他办法做到这一点吗？

- 可以区分，而且在`psh2.c`中我们就是利用`switch(fork_return_pid)`得以完成：

1. 错误处理的分支
2. 子进程执行的分支
3. 父进程执行的分支

用 `getpid()`和`getppid()`，若进程的ID为当前进程ID，进入父进程分支…；若不是，进而判断，若进程的父进程ID为当前进程ID，进入子进程分支…；否则错误处理…



##### 8.2 预测下面程序的输出

```c
main() {
    int n;
    for(n = 0; n < 10; n++) {
        printf("pid=%d, n=%d\n",getpid(),n);
        sleep(1);
        if(fork() != 0)
            exit(0);
    }
}
```

1. 应该输出十条“连续”（不一定完全连续+1，但是有序）的 **PID**; 

2. 输出十条同一个 **PID**.（没有`fork`新建进程）



##### 8.3 `psh2,c`使用了定长的数组来存放参数列表。如何修改程序才能去掉用户输入命令参数个数的限制？这样的改动有必要吗？这就是说，Unix是否限制了`exec`可接受的参数长度或个数？

增加 parse string 并转换成 arglist 的函数即可；应该没有限制。



##### 8.4 文件中会有几条记录？能否从记录的条数得知文件描述符和连接的文件？

测试程序，调用`fork`后两个进程都有一个指向同一个输出文件并且具有相同的当前位置的文件描述符。

```c
main() {
    int fd;
    int pid;
    char msg1[] = "test 1 2 3..\n";
    char msg2[] = "Hello, hello\n";
    if((fd = creat("testfile", 0644)) == -1)
        return 0;
    if(write(fd,msg1,strlen(msg1)) == -1)
        return 0;
    if((pid = fork()) == -1)
        return 0;
    if(write(fd,msg2,strlen(msg2)) == -1)
        return 0;

    close(fd);
    return 1;
}
```

3条记录：`msg1\n msg2\n msg2\n`；不能。



##### 8.5 测试程序，文件中有多少条记录？解释一下结果。

```c
#include <stdio.h>
main() {
    FILE *fp;
    int pid;
    char msg1[] = "test 1 2 3..\n";
    char msg2[] = "Hello, hello\n";
    if((fp = fopen("testfile2","w")) == NULL)
        return 0;
    fprintf(fp, "%s", msg1);
    if((pid = fork()) == -1)
        return 0;
    fprintf(fp, "%s", msg2);
    fclose(fp);
    return 1;
}
```

将这个程序的输出与课本中的`forkdemo1.c`输出比较一下。

4条记录：`msg1\n msg2\n msg1\n msg2\n`；

`fprintf`是libc提供的一个IO例程，它在默认情况下使用缓存机制， 这意味着所有写操作都存储在内存中的缓冲区中，直到缓冲区被刷新。



##### 8.6  解释程序做了些什么，怎么工作的，`Unix shell`允许用户在后台运行程序。这个程序与后台进程有什么相似之处？

```c
main() {
    int i;
    if(fork() != 0) {
        exit(0);
    }
    for(i = 1; i<=10;i++){
        printf("still here ..\n");
        sleep(1);
    }
    return 0;
}
```

`fork`出新进程后，父进程死亡并返回倒`shell`，第八章有提到这类进程成为“孤儿进程”。孤儿进程将被`init`进程（进程号为1）所收养，这有点像孤儿由国家监护。由于孤儿进程会被`init`进程给收养，所以孤儿进程不会对系统造成危害；

相似之处：守护进程（后台进程）的父进程一般都是`init`进程，因为它真正的父进程在`fork`出守护进程后就直接退出了，所以守护进程都是孤儿进程，由`init`接管；

守护进程其他特性：

- 守护进程是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或循环等待处理某些事件的发生；
- 守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机才随之一起停止运行；
- 守护进程一般都以root用户权限运行，因为要使用某些特殊的端口或者资源；



##### 8.7 如果子程序运行失败，程序调用`exit`。调用`exit`看起来很极端。为什么不仅仅从函数中返回出错的代码？

> **基础知识**
>
> 首先说一下fork和vfork的差别：
>
> - fork  是 创建一个子进程，并把父进程的内存数据copy到子进程中。
> - vfork是 创建一个子进程，并和父进程的内存数据share一起用。
>
> 这两个的差别是，一个是copy，一个是share。
>
> 你 man vfork 一下，你可以看到，vfork是这样的工作的，
> 1）保证子进程先执行。
> 2）当子进程调用exit()或exec()后，父进程往下执行。
>
> 那么，为什么要干出一个vfork这个玩意？  原因是这样的—— **起初只有fork，但是很多程序在fork一个子进程后就exec一个外部程序，于是fork需要copy父进程的数据这个动作就变得毫无意了，而且还很重，所以，搞出了个父子进程共享的vfork。所以，vfork本就是为了exec而生。**
>
> **为什么return会挂掉，exit()不会？**
>
> 从上面我们知道，**结束子进程的调用是exit()而不是return，如果你在vfork中return了，那么，这就意味main()函数return了，注意因为函数栈父子进程共享，所以整个程序的栈就跪了。**
>
> 
> 如果你在子进程中return，那么基本是下面的过程：
>
> 1. **子进程的main() 函数 return了**
> 2. **而main()函数return后，通常会调用 exit()或相似的函数**（如：exitgroup()）
> 3. **这时，父进程收到子进程exit()，开始从vfork返回，但是尼玛，老子的栈都被你干废掉了，你让我怎么执行？**（注：栈会返回一个诡异一个栈地址，对于某些内核版本的实现，直接报“栈错误”就给跪了，然而，对于某些内核版本的实现，于是有可能会再次调用main()，于是进入了一个无限循环的结果，直到vfork 调用返回 error）
>
> 
>
> 好了，现在再回到 return 和 exit，return会释放局部变量，并弹栈，回到上级函数执行。exit直接退掉。如果你用c++ 你就知道，return会调用局部对象的析构函数，exit不会。（注：exit不是系统调用，是glibc对系统调用 _exit()或_exitgroup()的封装）
>
> 可见，**子进程调用exit() 没有修改函数栈，所以，父进程得以顺利执行**。
>
> 作者：陈皓
> 链接：https://www.zhihu.com/question/26591968/answer/33639916
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 进程和程序——编程练习

##### 8.9 拓展`waitdemo.c`的功能，使之建立两个进程，并等待两个进程都结束。



**进一步拓展你的程序使之能从命令行接收整数。然后程序创立该整数指定的进程数。分配每个进程一个随机的睡眠时间。最后，父进程报告每个子进程的退出。**

